module Padrino
  module PathRouter
    #
    # High performance engine for finding all routes which are matched with pattern
    #
    class Compiler
      # All regexps generated by recursive compiler
      attr_reader :regexps

      ##
      # Constructs an instance of Padrino::PathRouter::Compiler
      #
      def initialize(routes)
        @routes = routes
      end
  
      ##
      # Finds all routes which are matched with the condition.
      #
      def call(request)
        compile! unless compiled?
        pattern, verb, params = parse_request(request)
        candidacies = match_with(pattern)
        raise_exception(404) if candidacies.empty?
        candidacies, allows = candidacies.partition{|route| route.verb == verb }
        raise_exception(405, verbs: allows.map(&:verb)) if candidacies.empty?
        candidacies.map{|route| [route, route.params_for(pattern, params)]}
      end

      ##
      # Compiles all routes into regexps.
      #
      def compile!
        return if compiled?
        @regexps = @routes.map.with_index do |route, index|
          route.index = index
          /(?<_#{index}>#{route.matcher.to_regexp})/
        end
        @regexps = recursive_compile(@regexps)
        @compiled = true
      end

      ##
      # Returns true if all routes has been compiled.
      #
      def compiled?
        !!@compiled
      end
  
      private

      ##
      # Compiles routes into regexp recursively.
      #
      def recursive_compile(regexps, paths = [])
        return paths if regexps.length.zero?
        paths << Regexp.union(regexps)
        regexps.shift
        recursive_compile(regexps, paths)
      end
  
      ##
      # Returns all routes which are matched with a pattern.
      #
      def match_with(pattern)
        offset = 0
        conditions = [pattern]
        conditions << pattern[0..-2] if pattern != "/" && pattern.end_with?("/")
        loop.with_object([]) do |_, candidacies|
          return candidacies unless conditions.any?{|x| @regexps[offset] === x }
          route = @routes[offset..-1].detect{|route| Regexp.last_match("_#{route.index}") }
          candidacies << route
          offset = route.index + 1
        end
      end
  
      ##
      # Parses request and then returns an array.
      # 
      def parse_request(request)
        if request.is_a?(Hash)
          [request['PATH_INFO'], request['REQUEST_METHOD'].downcase.to_sym, {}]
        else
          [request.path_info, request.request_method.downcase.to_sym, request.params]
        end
      end
  
      ##
      # Raises an exception.
      #
      def raise_exception(error_code, options = {})
        raise ->(error_code) {
          case error_code
          when 400
            BadRequest
          when 404
            NotFound
          when 405
            MethodNotAllowed.new(options[:verbs])
          end
        }.call(error_code)
      end
    end
  end
end
